\documentclass{classrep}
\usepackage[utf8]{inputenc}
\usepackage[pdftex]{graphicx}
\usepackage[polish]{babel}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{multicol}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{array}
\usepackage{multirow}
\usepackage{url}

\studycycle{Informatyka, studia dzienne, II st.}
\coursesemester{I}

\coursename{Metody Obliczeniowe Optymalizacji}
\courseyear{2010/2011}

\courseteacher{xxxxxx}
\coursegroup{czwartek, 14:15}
\svnurl{xxxxxx}

\author{%
  \studentinfo{Michał Janiszewski}{169485} \and
  \studentinfo{Leszek Wach}{xxxxxx}
}

\title{Zadanie 2: Optymalizacja kierunkowa}

\floatname{algorithm}{Algorytm}

\begin{document}

\maketitle

\section{Cel zadania}
Celem zadania było napisanie programu, który dla dowolnej funkcji dwóch zmiennych znajdzie jej minimum wzdłuż wyznaczonego odcinka \ppauza dokona minimalizacji kierunkowej. Operacja ta ma odbywać się z wykorzystaniem trzech kryteriów:
\begin{enumerate}
 \item Armijo,
 \item Wolfa,
 \item Goldensteina.
\end{enumerate}

\section{Metoda rozwiązania}
W celu rozwiązania zadania stworzyliśmy skrypt programu Matlab. Skrypt prezentuje użytkownikowi okienko GUI, w którym należy wprowadzić parametry:
\begin{description}
 \item[funkcja] funkcja, która poddawana będzie optymalizacji, oznaczona jako $F$,
 \item[start] punkt początkowy, oznaczany jako $p_0$,
 \item[direction] kierunek; wektor od punktu początkowego do końcowego, oznaczany jako $\overrightarrow{d}$,
 \item[c$_1$, c$_2$] parametry określające zachowanie się metod\footnote{Znaczenie tych parametrów zostanie omówione wraz z metodami.},
 \item[$\rho$] współczynnik zmiany kroku,
 \item[$\epsilon$] pożądana dokładność rozwiązania,
\end{description}
należy także wybrać jedno z dostępnych kryteriów.

Zadaniem programu jest poszukiwanie pewnej wartości kroku $\lambda$, która wyraża krotność wektora kierunku rozpoczynającego się w punkcie startowym. Krok ten będzie odpowiadał znalezionemu minimum. Zależność pomiędzy wartością $\lambda$, a wartością funkcji $F$ prezentuje poniższy wzór:
\begin{equation}
 f(\lambda) = F(p_0.x + \lambda \cdot d.x, p_0.y + \lambda \cdot d.y)
\end{equation}

Należy zauważyć, że wartościom kroku należącym odcinka $\overline{p_0, p_0 + \overrightarrow{d}}$ odpowiadają wartości [0,~1].

Poszukiwanie wartości kroku jest metodą iteracyjną, która w każdej iteracji przybliża wartość rozwiązania, aż do osiągnięcia zadanego warunku stopu \ppauza w tym przypadku jest to kryterium stacjonarości:
\begin{equation}
 \lvert\nabla f(\lambda)\rvert \leq \epsilon
\end{equation}

Punktem $p_k$ nazywać będziemy przybliżenie rozwiązania wyznaczone w $k$-tej iteracji, zaś symbolem $\lambda_k$ oznaczać będziemy krok podjęty w $k$-tej iteracji. Zależności pomiędzy tymi zmiennymi prezentują równania:
\begin{equation}
 \lambda = \displaystyle\sum\limits_{i=0}^n \lambda_i
\end{equation}
gdzie $n$ oznacza całkowitą ilość iteracji oraz:
\begin{equation}
 p_k = p_0 + \displaystyle\sum\limits_{i=0}^k \lambda_i \cdot d
\end{equation}


\section{Kryteria}
Poza wymaganiem poprawy\footnote{Wartość $f(\lambda)$ dla każdego kolejnego oszacowania $\lambda$ powinna być mniejsza.}, stosowane są dodatkowe kryteria, które spełniają rolę kryterium stopu. Dzięki ich wykorzystaniu zapewniamy dokładniejsze i szybsze znalezienie rozwiązania.

Każde z kryteriów zaimplementowane jest jako rekurencyjna metoda, której działanie przedstawia następujący algorytm:
\begin{enumerate}
 \item Pobierz od użytkownika wszystkie dane,
 \item podstaw $\lambda_0 = 0$
 \item jak $\lambda_k$ podstaw znak pochodnej $sign(f(\lambda))$,\label{alg:start}
 \item sprawdź wybraną metodą, czy $f(\lambda + \lambda_k)$ spełnia warunki,\label{alg:one}
 \item jeśli spełnia: podstaw $\lambda_k = \rho \cdot \lambda_k$, przejdź do \ref{alg:one},
 \item jeśli nie jest spełniony warunek stacjonarości, rekurencyjnie przejdź do \ref{alg:start},
 \item zakończ obliczenia, zwróć $\lambda$ i ilość wywołań.
\end{enumerate}


\subsection{Kryterium Armijo}
Najprostszy test, kryterium Armijo, sprawdza czy spadek wartości funkcji w danej iteracji jest nie mniejszy niż jej pochodna przemnożona przez obrany parametr $c_1$. Warunek ten można zapisać w następujący sposób:
\begin{equation}
 f(\lambda + \lambda_k) \leq f(\lambda) + c_1 \cdot \lambda_k \cdot f'(\lambda)
\end{equation}

\subsection{Kryterium Wolfa}
Podstawową wadą kryterium Armijo jest ograniczanie tylko maksymalnej długości kroku, co może prowadzić do bardzo wolnej zbieżności \ppauza poprzez stosowanie możliwie najmniejszego kroku $\lambda_k$.

Kryterium Wolfa łączy kryterium Armijo z testem krzywizny, który ogranicza wartość kroku od dołu:

\begin{eqnarray}
    f(\lambda + \lambda_k)  & \leq & f(\lambda) + c_1 \cdot \lambda_k \cdot f'(\lambda) \\
    f'(\lambda + \lambda_k) & \geq & c_2 \cdot f'(\lambda)
\end{eqnarray}
gdzie $c_1 \in (0, 1)$, natomiast $c_2 \in (c_1, 1)$.

Zadaniem tego kryterium jest zagwarantowanie, że w miejscu dużego spadku funkcji, krok nie będzie mały.

\subsection{Kryterium Goldsteina}
Podobnie jak kryterium Wolfa, kryterium Goldsteina kontroluje zarówno górną jak i dolną granicę kroku zabezpieczając przed zbyt wolnym testowaniem zbieżności.

Tak jak w poprzednim przypadku, również tu wykorzystane jest kryterium Armijo do określania górnej granicy.

\begin{eqnarray}
    f(\lambda + \lambda_k) & \leq & f(\lambda) + c_1 \cdot \lambda_k \cdot f'(\lambda) \\
    f(\lambda + \lambda_k) & \geq & f(\lambda) + (1 - c_1) \cdot \lambda_k \cdot f'(\lambda)
\end{eqnarray}
gdzie $c_1 \in (0, \frac{1}{2})$.

\begin{thebibliography}{99}
\bibitem{grega.wyklad}
Grega, Wojciech. \textit{Metody optymalizacji. Wykład 4} [online]. [dostęp: 27
marca 2011]. Dostępny w Internecie:
http://aq.ia.agh.edu.pl/Aquarium/Dydaktyk/Wyklady/MO/2005-06/Wyklad04.PDF
\end{thebibliography}

\end{document}
